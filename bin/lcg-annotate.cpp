#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <getopt.h>

#include "common.h"
#include "recorders.h"

using namespace lcg;

struct options {
        options() {
                filename[0] = 0;
                comment[0] = 0;
        }
        char filename[FILENAME_MAXLEN];
        char comment[COMMENT_MAXLEN];
};

static struct option longopts[] = {
        {"help", no_argument, NULL, 'h'},
        {"file", required_argument, NULL, 'f'},
        {"message", required_argument, NULL, 'm'},
        {NULL, 0, NULL, 0}
};

const char lcg_annotate_usage_string[] =
        "This program adds comments to existing H5 files generated by lcg.\n\n"
        "Usage: lcg annotate [<options> ...]\n"
        "where options are:\n"
        "   -h, --help     print this help message and exit\n"
        "   -f, --file     name of the file to annotate\n"
        "   -m, --message  comment to write into the file\n";

void usage()
{
        printf("%s\n", lcg_annotate_usage_string);
}

void parse_args(int argc, char *argv[], options *opts)
{
        int ch;
        while ((ch = getopt_long(argc, argv, "hf:m:", longopts, NULL)) != -1) {
                switch(ch) {
                case 'f':
                        sprintf(opts->filename, "%s", optarg);
                        break;
                case 'm':
                        sprintf(opts->comment, "%s", optarg);
                        break;
                case 'h':
                default:
                        Logger(Critical, "Enter 'lcg help annotate' for help on how to use this program.\n");
                        exit(1);
                }
        }
}

herr_t counter(hid_t location_id /*in*/, const char *attr_name /*in*/,
                const H5A_info_t *ainfo /*in*/, void *op_data /*in,out*/) {
        int next = *((int*)op_data);
        int current = atoi(attr_name);
        if (current >= next)
                next = current+1;
        *((int*)op_data) = next;
        return 0;
}

int writeComment(const char *filename, const char *comment)
{
        struct stat buf;

        if (stat(filename, &buf) < 0) {
                Logger(Critical, "%s: no such file.\n", filename);
                return -1;
        }

        hid_t fid, grp, dspace, atype, attr;
        hsize_t n = 0;
        herr_t status;
        int next = -1;
        char tag[4];

        // open the file
        fid = H5Fopen(filename, H5F_ACC_RDWR, H5P_DEFAULT);
        if (fid < 0) {
                Logger(Critical, "%s: unable to open file.\n", filename);
                return -1;
        }
        Logger(Debug, "Successfully opened HDF5 file %s.\n", filename);

        // open the comments group
        grp = H5Gopen(fid, COMMENTS_GROUP, H5P_DEFAULT);
        if (grp < 0) {
                Logger(Critical, "%s: unable to open group.\n", COMMENTS_GROUP);
                H5Fclose(fid);
                return -1;
        }
        Logger(Debug, "Successfully opened comments group.\n");

        // find out how many comments are already present
        status = H5Aiterate2(grp, H5_INDEX_NAME, H5_ITER_INC, &n, counter, (void *) &next);
        if (status < 0) {
                Logger(Critical, "Unable to iterate over all attributes.\n");
                H5Gclose(grp);
                H5Fclose(fid);
        }
        sprintf(tag, "%03d", next);
        Logger(Debug, "The next attribute will have tag [%s]\n", tag);

        // create a dataspace for the comment
        dspace = H5Screate(H5S_SCALAR);
        if (dspace < 0) {
                Logger(Critical, "Error in H5Screate.\n");
                H5Gclose(grp);
                H5Fclose(fid);
                return -1;
        }

        atype = H5Tcopy(H5T_C_S1);
        if (atype < 0) {
                Logger(Critical, "Error in H5Tcopy.\n");
                H5Sclose(dspace);
                H5Gclose(grp);
                H5Fclose(fid);
                return false;
        }
        Logger(Debug, "Successfully copied type.\n");

        status = H5Tset_size(atype, strlen(comment) + 1);
        if (status < 0) {
                Logger(Critical, "Error in H5Tset_size.\n");
                H5Tclose(atype);
                H5Sclose(dspace);
                H5Gclose(grp);
                H5Fclose(fid);
                return false;
        }
        Logger(Debug, "Successfully set type size.\n");

        status = H5Tset_strpad(atype, H5T_STR_NULLTERM);
        if (status < 0) {
                Logger(Critical, "Error in H5Tset_strpad.\n");
                H5Tclose(atype);
                H5Sclose(dspace);
                H5Gclose(grp);
                H5Fclose(fid);
                return false;
        }
        Logger(Debug, "Successfully set type padding string.\n");

        // create an attribute to the comments group
        attr = H5Acreate2(grp, tag, atype, dspace, H5P_DEFAULT, H5P_DEFAULT);
        if (attr < 0) {
                Logger(Critical, "Error in H5Acreate2.\n");
                H5Tclose(atype);
                H5Sclose(dspace);
                H5Gclose(grp);
                H5Fclose(fid);
                return false;
        }
        Logger(Debug, "Successfully created attribute.\n");

        // write the attribute
        status = H5Awrite(attr, atype, comment);
        if (status < 0)
                Logger(Critical, "Error in H5Awrite.\n");
        else
                Logger(Debug, "Successfully written string attribute.\n");

        H5Aclose(attr);
        H5Tclose(atype);
        H5Sclose(dspace);
        H5Gclose(grp);
        H5Fclose(fid);
        
        return (int) status;
}

int main(int argc, char *argv[])
{
        options opts;

        parse_args(argc, argv, &opts);

        if (!strlen(opts.filename)) {
                fprintf(stdout, "Enter the name of the file you want to annotate: ");
                fscanf(stdin, "%s", opts.filename);
                fflush(stdin);
        }

        if (!strlen(opts.comment)) {
                fprintf(stdout, "Enter the comment: ");
                fscanf(stdin, "%s", opts.comment);
                fflush(stdin);
        }

        // add a timestamp to the comment
        recorders::Comment comment(opts.comment);

        return writeComment(opts.filename, comment.message());
}

