The primary application of \progname is to perform electrophysiology
experiments. Albeit not necessary, as it will be described in the
following, it is however recommended to install \progname on a Linux
machine with a data acquisition card and a working installation of the
Comedi library. A real-time kernel is required only to perform
closed-loop or dynamic clamp experiments.

It is also possible to install \progname on any UNIX compatible
operating system (Linux or Mac OS X, for instance) without Comedi and
real-time capabilities. This approach can be useful to familiarize
with the program and to develop new experiments. A detailed
description of how to do this is given in Sec.~\ref{install:nokernel}.

In the following section, we describe how to set up a Linux machine
with a real-time kernel and Comedi and how to install \progname. We
assume that you have a working Linux installation: if that is not the
case, refer to the documentation of one of the multiple distributions
available. In our laboratory we use Debian and therefore the
following instructions will be based on this distribution.

\section{Configuration of the Linux box}
\progname can be installed on a variety of Linux distributions. Here,
we will refer to the stable version of Debian at the time of this
writing (\emph{Squeeze 6.0}).

\subsection{Patching and installing the realtime kernel}
If you don't want to use the real-time capabilities of \progname you
can skip this paragraph.

This is potentialy the most difficult part of the installation. In
order to achieve nanosecond precision, \progname requires a kernel
with real-time capabilities. Both \href{http://www.rtai.org}{RTAI} or
\textbf{\href{https://rt.wiki.kernel.org/index.php/Main\_Page}{PREEMPT\_RT}}
can be used. The latter is advisable since RTAI does not include
support for the latest kernels, which might work better with the most
recent hardware.

You may need to install tools to build the kernel. In Debian you can
type, as root:
\begin{lstlisting}
apt-get update
apt-get install build-essential binutils-dev libelf-dev libncurses5
libncurses5-dev git-core make gcc subversion libc6 libc6-dev automake
libtool bison flex autoconf flex libgsl0-dev 
\end{lstlisting}

\begin{enumerate}
\item \textbf{Check which kernels and patches are available.}
  It is advisable to install the real-time patch on a ``vanilla''
  kernel. To do so, navigate to
  \texttt{\href{http://www.kernel.org/pub/linux/kernel/projects/rt/}{the
      kernel.org ``rt'' project page}} and check which patches are
  available for the kernel that you wish to install. 
\item \textbf{Download the kernel and the realtime patch} The
  directory \textbf{/usr/src} is a common place to install the Linux
  kernel. You will need to have root access to perform these
  operations.
  \begin{lstlisting}
    cd /usr/src
    wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.8.4.tar.bz2
    wget http://www.kernel.org/pub/linux/kernel/projects/rt/3.8/patch-3.8.4-rt2.patch.bz2
  \end{lstlisting}
\item \textbf{Decompress and patch the kernel.} Patching the kernel
  will add realtime support to the kernel you have downloaded.
  \begin{lstlisting}
    tar xvf linux-3.8.4.tar.bz2
    ln -s linux-3.8.4 linux
    cd linux
    bzcat ../patch-3.8.4-rt2.patch.bz2 | patch -p1
  \end{lstlisting}
\item \textbf{Configure the kernel.} The easiest way to do this is to
  use the configuration file from a kernel that was previously
  installed in your system or from a similar installation/system.
  \begin{lstlisting}
    cp /boot/config-`uname -r` .config
    make oldconfig
    make menuconfig
  \end{lstlisting}
  This will evoke a user interface to configure the kernel options.
You need to set the \texttt{Preemption model} to \texttt{Fully
  Preemptible Kernel (RT)} in the \texttt{Processor type and
  features}. Disable \texttt{CPU Frequency scaling} under
\texttt{Power Management and ACPI options} and \texttt{Check for
  stack overflow} and the options under \texttt{Tracers} (the later to
make the kernel smaller) in \texttt{Kernel hacking}. Additionally you
should also disable the \texttt{Comedi drivers} under the
\texttt{Staging drivers} of the \texttt{Device drivers} menu. Save and
exit.
\item \textbf{Compile and install the kernel.} This step might take several
  minutes to hours, depending on the size of the kernel and on the
  speed of your machine.
\begin{lstlisting}
make && make modules && make modules_install && make install
\end{lstlisting}
When the installation is complete you will need to update the boot loader.
\begin{lstlisting}
cd /boot
update-initramfs -c -k 3.8.4-rt2
update-grub
\end{lstlisting}
Check that grub has been updated. You should see an entry with the
name of the newly installed kernel in
\texttt{/etc/grub/menu.lst}. You can now reboot into your new kernel.
\end{enumerate}

\subsection{Installation of the dependencies}
\label{install:required}
\progname makes use of several libraries:
\begin{enumerate}
\item \textbf{BOOST C++ library.}
  In order for \progname to work you will need to install the
  \href{http://www.boost.org}{BOOST C++ library}. Only the last
  command needs to be run as root.
  \begin{lstlisting}
    wget http://sourceforge.net/projects/boost/files/boost/1.53.0/boost_1_53_0.tar.bz2
    tar --bzip2 -xvf boost_1_53_0.tar.bz2
    cd boost_1_53_0.tar.bz2
    ./bootstrap.sh
    ./b2 install
  \end{lstlisting}
\item \textbf{Comedi.}
By default, \progname uses Comedi to interface to supported data
acquisition cards. The installation of Comedi consists of three parts:
a kernel-space library (\texttt{comedi} itself), a user-space
interface (\texttt{comedilib}) and some additional programs for the
calibration of the board (\texttt{comedi\_calibrate}). They can be
downloaded from the following Git repositories:
\begin{lstlisting}
git clone git://comedi.org/git/comedi/comedi.git
git clone git://comedi.org/git/comedi/comedilib.git
git clone git://comedi.org/git/comedi/comedi_calibrate.git
\end{lstlisting}
You now need to install each of these modules, starting with the kernel module:
\begin{lstlisting}
cd comedi
./autogen.sh
./configure --with-linuxdir=/usr/src/linux
make
\end{lstlisting}
Then as root:
\begin{lstlisting}
make install
depmod -a
\end{lstlisting}
Now for comedilib, the user space interface to the kernel module (run \texttt{make install} as root):
\begin{lstlisting}
cd comedilib
./autogen.sh
./configure --prefix=/usr/local
make
make install
\end{lstlisting}
And similarly for comedi\_calibrate, the tools to calibrate the DAQ cards (install the Boost headers before this step):
\begin{lstlisting}
cd comedi_calibrate
./autogen.sh
./configure --prefix=/usr/local
make
make install
\end{lstlisting}
Now that the drivers are installed you need to create the rules to
allow users to access the devices. To do that, create, as root, a file
called \inlineCode{/etc/udev/rules.d/99-comedi.rules} and add the
following line to it: \texttt{KERNEL=="comedi0", MODE="0666"}. In case
you have multiple acquisition cards, add a line for each of them.
\item \textbf{HDF5 library.}
The \href{http://www.hdfgroup.org/HDF5/}{HDF Group} designed a set of
libraries for data storage and management with high performance,
efficiency and high volume/complexity in mind. \textbf{\progname} uses
this library to save binary data files. The
library can be installed from source or using Debian repositories
(as root):
\begin{lstlisting}
apt-get install hdf5-tools hdf5-serial-dev
\end{lstlisting}
\end{enumerate}

\section{Installation of \progname}
\label{install:program}
To install \progname, start by getting it from the
\href{https://github.com/danielelinaro/dynclamp}{GithHub
  repository}. We recommend to install \progname in a local folder, so
that it is easier to have multiple installations for different users.
\begin{lstlisting}
mkdir $HOME/local
git clone https://github.com/danielelinaro/dynclamp.git lcg
cd lcg
./autoreconf -i
./configure --prefix=$HOME/local
make
make install
\end{lstlisting}

To allow non-root users to run \progname, you need to create a
realtime group to which users will be added. To do so, as root add
the following lines to \texttt{/etc/security/limits.conf}.
\begin{lstlisting}
@realtime       -       rtprio  99
@realtime       -       memlock unlimited
\end{lstlisting}
Then, create a group \texttt{realtime} and add the users that you want
to be able to use \progname.
\begin{lstlisting}
groupadd realtime
usermod -a -G realtime USER
\end{lstlisting}
You need to log out and log back in for the changes to take effect.

\subsection{Installation of the Python bindings}
\progname comes with a set of Python scripts that can be used both to
perform standard electrophysiology experiments and as starting point
for developing new protocols.

The full list of available protocols is described in
Chapter~\ref{chap:protocols}: here, we only describe how to install
the Python bindings and their dependencies.

Start by installing  \texttt{numpy}, \texttt{scipy},
\texttt{matplotlib} and \texttt{pytables} if they are not already
present on your system. In Debian this can be accomplished with the
following command.
\begin{lstlisting}
apt-get install python-numpy python-scipy python-matlablib python-tables
\end{lstlisting}
Alternatively, to have the latest version of the modules, you can
install them from source.

To install \progname Python module, from the base directory (i.e.,
where you cloned the Git repository) type:
\begin{lstlisting}
cd python
python setup.py build
python setup.py install --prefix=$HOME/local
\end{lstlisting}

This will install the module in the directory
\inlineCode{$HOME/local/lib/python2.6/site-packages}, which needs to
be added to your \inlineCode{PYTHONPATH} environment variable, by
adding the following line to your \inlineCode{.bashrc} file:
\begin{lstlisting}
export PYTHONPATH=$PYTHONPATH:$HOME/local/lib/python2.6/site-packages
\end{lstlisting}

\section{Final configuration}
In order for \progname to function properly, a few configuration steps
must be completed. First of all, add the directory where \progname
binaries where installed to your path. To do this, add the following
line to your \inlineCode{.bashrc} file:
\begin{lstlisting}
export PATH=$PATH:$HOME/local/bin
\end{lstlisting}
After this, copy the files \inlineCode{lcg-env.sh} and
\inlineCode{lcg-completion.bash} from \progname base directory to your
home directory:
\begin{lstlisting}
cp lcg-env.sh ~/.lcg-env.sh
cp lcg-completion.bash ~/.lcg-completion.bash
\end{lstlisting}
Source them any time you log in by adding the following lines to your
\inlineCode{.bashrc} file:
\begin{lstlisting}
source ~/.lcg-env.sh
source ~/.lcg-completion.bash
\end{lstlisting}
The script in \inlineCode{lcg-completion.bash} provides autocomplete
capabilities to \progname but is not required for correct
functioning. The environment variables exported in
\inlineCode{lcg-env.sh}, on the other hand, provide necessary defaults
to \progname and should be tailored to your system. In particular, the
file exports the following variables:
\begin{itemize}
\item \textbf{COMEDI\_DEVICE} The path to the device file from which
  data is read.
\item \textbf{AI\_CONVERSION\_FACTOR\_CC} The conversion factor to be used for
  the analog input, in current clamp mode.
\item \textbf{AO\_CONVERSION\_FACTOR\_CC} The conversion factor to be used for
  the analog output, in current clamp mode.
\item \textbf{AI\_CONVERSION\_FACTOR\_VC} The conversion factor to be used for
  the analog input, in voltage clamp mode.
\item \textbf{AO\_CONVERSION\_FACTOR\_VC} The conversion factor to be used for
  the analog output, in current clamp mode.
\item \textbf{RANGE} The range of the output to the analog card.
\item \textbf{AI\_SUBDEVICE} The analog input subdevice on the
  acquisition card.
\item \textbf{AI\_CHANNEL} The default channel used for analog input.
\item \textbf{AO\_SUBDEVICE} The analog output subdevice on the
  acquisition card.
\item \textbf{AO\_CHANNEL} The default channel used for analog output.
\item \textbf{AI\_UNITS\_CC} The units for the analog input, in current
  clamp mode.
\item \textbf{AO\_UNITS\_CC} The units for the analog output, in current
  clamp mode.
\item \textbf{AI\_UNITS\_VC} The units for the analog input, in voltage
  clamp mode.
\item \textbf{AO\_UNITS\_VC} The units for the analog output, in voltage
  clamp mode.
\item \textbf{SAMPLING\_RATE} The default sampling rate of the acquisition.
\item \textbf{GROUND\_REFERENCE} The ground reference of the
  acquisition card. At present, Ground-Referenced Single Ended (GRSE)
  and Non-Referenced Single Ended (NRSE) are supported.
\end{itemize}
Most of the previous values depend on how your amplifier is configured
and on how it is wired to the acquisition card. It is also important to
note that the conversion factors and the units provided in
\inlineCode{.lcg-env.sh} are meaningful when only one input and output
channels are present. In all other cases, input/output conversion
factors will have to be specified either in the configuration file or
when invoking a script.

\section{Installation without a realtime kernel}
\label{install:nokernel}
If you want to learn how to work with \progname or test configuration
files, it is possible to install \progname on your personal
computer. \progname can be compiled on any UNIX-like operating system,
such as Linux and Mac OS X. To do so, you just need to install
\texttt{BOOST} and the \texttt{HDF5} library (see
Sec.~\ref{install:required}). The procedure to install \progname is
the same as described in Sec.~\ref{install:program}: the
\inlineCode{configure} script will detect the absence of Comedi and of
the real-time kernel and not compile parts of \progname.


